### 1、基本概念
+ 不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做；
+ 可靠传输服务：想办法实现发送端发送什么，接收端就接收什么；
+ 不仅只局限于数据链路层；
### 2、可靠传输的实现机制——停止等待协议
![换算单位](计算机网络/imgs/3.4(1).png)
+ 对于发送方发送的分组数据，发送方会将发送的分组数据进行序列化即用比特0或1来区分本次分组数据和下组数据，本次分组数据使用分组序号发出并被接收方接收后那么接收方则会返回一个一样序列号的确认码，当发送方接收到确认码之后，就会发送下一个编码，并将之前序列号为0的数据缓存释放删除以分配给下一组数据
+ 若分组数据在途中丢失，那么发送方就会处于待接收确认码的状况，发送方自置一个延时器，一旦超过延时器的时间（略大于发送方到接收方的平均往返时间），那么便会重发
+ 若分组数据重复，接收方会根据分组数据的序号来确认此次数据是否与上次传输的重复，若重复则丢弃，并返回一个确认码并且确认码的序号为重复的序号
+ 若确认码遗失或超时，发送方会重发直至相应的确认码发送回发送方
### 2、可靠传输的实现机制——回退N帧协议GBN
![换算单位](计算机网络/imgs/3.4(2).png)
+ ![换算单位](计算机网络/imgs/3.4(3).png)
+ 对于停止等待协议，信道利用率实在太低
+ 于是为了提高信道利用率我们将分组编号的比特位增大，例如比特位分3个那么，数据分组则可以分为0~7，然后我们采用接收位和发送位W其中，W<=7；那么若编号n%7处于0~W中则视为发送窗口，将这发送窗口里面的分组数据全可发送出去，那么接收方也要准备接收窗口，接收分组0~7，并且与发送方的分组需要一一对应，接收窗口为1个分组数据，并且接收窗口Wr指向开头font->，当接收方收到发送方发送的数据后，Wr每收到一个那么接收窗口向后移动一位，并返回一位确认码，于是发送方收到一个确认码就将发送窗口向后移动一位置，但接收方不一定要逐个发送，那么就用累计确认方法
+ 累计确认：当接收方收到连续的分组数据后，于是当连续收到分组数据0、1后那么接收方就返回ACK1表示收到0到1的分组数据了，当分组数据0~4全部收到后，那么接收方返回ACK4确认分组，确认分组即为最后一个分组，表示前五个都已经收到了，发送方根据ACK4把前5条分组删除，其中ACK4表示接收到的分组数据编号的最后一位，滑动窗口向前滑动5个位置，这样，确认分组不用每一组就发送一条确认分组了，提高效率
+ 发生误码：若发送方发送的分组5~1中若序号为7的分组数据出现误码，那么接收方不再接收7及其以后的分组，先返回一个5到6分组的确认码，即ACK6，而7后面的分组数据无法与接收方的序号一致，则7及其以后会被丢弃，返回3个ACK6，接收方收到第一个ACK6后，将发出窗口向后移动两位，而后面收到3个ACK6因为已经受到过ACK6那么就从分组编号为7的分组数据再发送发送窗口的分组数据。
### 2、可靠传输的实现机制——选择重传协议SR
+ 对于回退N帧协议GBN，接收窗口Wr只能为1，因此接收方只有按序接收到正确的数据分组，但是一旦一个分组中出现误码，将会导致后面的分组无法被接收，而丢弃，发送方于是重发，这必然会导致超时重传，这是一种浪费
+ 那么，我们将接收窗口扩大至与发送窗口一样大，例如分组的比特位为3位，那么分组为0~7，此时发送窗口为5即0~4，那么接收方也应一样，此时发送方发送了0到4的分组数据，其中2号分组数据出现误码，接收方逐一接收分组数据，当收到分组编号为1的时候返回一个确认分组，ACK0，ACK1，分组2为误码那将不接收2，此时继续接收3和4，并返回ACK3，和ACK4，此时接收方接收窗口向后滑动两个分组，发送方接收到ACK0和ACK1后发送窗口向后滑动两个分组，此时发送窗口进来5和6并将5和6发送出去1和2释放缓存，然后收到3和4后，将分组数据3和4标记为确认收到分组确保不会重发，此时5和6到达接收方，接收方并返回对应的ACK码，此时发送方2还未收到确认码，那么发送方会将2重新发送，此时接收方的接收窗口3，4，5，6已经收到但不可向后滑动，因为2未收到，等到2收到并返回一个ASK2后向后滑动5个分组，发送方收到ACK2后向前滑动5个分组；