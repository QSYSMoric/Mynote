### 1、概述
+ 执行上下文简称上下文，变量或函数的上下文决定了它门可以访问哪些数据，以及它们的行为。每个上下文都有一个**变量对象**
+ 全局上下文就是window对象，所有通过var创建的全局变量都是window的属性和方法
+ 作用域链，即标识一个函数中可以访问的变量
+ 一个作用域链，内部的上下文可以访问外部的上下文对象，而外部的无法访问内部的，且同级上下文无法互相访问
+ 函数提升，预编译会提升变量与函数声明
### 2、作用域
+ 即不同函数变量上下文的作用域，一个函数内嵌函数对于内嵌函数来说外部函数的变量就是它的全局变量，而window变量也是它的全局变量
+ 于是产生了作用域链，由外到内，也相当于一个栈
+ 当一个函数执行的时候，首先压入window全局上下文变量对象，再压入外部函数上下文，再压入内嵌函数上下文（前提是内嵌函数被执行），当内嵌函数执行完毕后弹出上下文并释放，逐步直至所有函数执行，也就是说当window文档一打开便开启了上下文栈（这特么不就是栈区么，屮）
### 3、作用域链增强
+ 执行上下文主要有两种全局上下文和函数上下文，但还有一种用于增强上下文
```js
        function fn(){
            let qs = "?debug=true";
            with( location ){
                var url = href + qs;
            }
            return url;
        }
        console.log(fn());
```
+ 在这里url使用let会报错，因为涉及到作用域，let为块级作用域
### 4、变量声明
1. **使用var的函数作用域声明**
	+ 在使用var声明变量时，变量会自动被添加到最接近的上下文。在函数中最接近的上下文就是函数上下文，而在with语句中with不属于函数上下文，而仅仅只是简单的一个区域上下文，如果在with中使用var声明那么就是函数上下文
	+ 若未添加任何声明则为全局上下文
	+ var声明会被拿到全局或者函数的顶部，位于作用域中所有代码之前
2. **使用let的块级作用域声明**
	+ es6新增的let块级跟var相似，但作用域为块级，作用域属于最近的一对{ }作用域
3. **使用const的常量声明**
	+ 使用const声明的变量不可修改，且引用类型不可修改指向
4. **标识符查找**
	+ 利用变量的作用域链的特点，可以通过特性，查找特定的标识符
```js
        let color = "blue";
        function fn(){
            return color;
        }
        console.log(fn());//blue
```
