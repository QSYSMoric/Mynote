+ ECMAScript中：
	+ 原始值，即6种原始类型的值，把一个原始类型的值赋给一个变量，也就是直接操作的内存值
	+ 引用值，即由多个值构成的一个对象，在对对象进行操作的时候我们实际操作的是该对象引用，而并非实际内存，例如若改变对象
### 1、动态属性
+ 原始值与引用值的定义方式类似，但引用值可以有属性但原始值没有属性
+ 引用值可以动态的增删改它的属性
### 2、复制值
+ 原始值在复制值的时候，会在栈区开辟新的空间，通过变量把一个原始值赋值到新开辟的空间，因此复制原始值实际上开辟了两个空间：
```js
        let num1 = 5;
        console.log( num1 );//5
        let num2 = num1;
        num2 = 1;
        console.log( num1 );//5
```
+ 而引用值的复制则不是，首先引用会在堆区开辟一个空间，而引用值会指向这个空间，复制一个引用实际上就是增加一个引用指向这个空间，而不会新开辟一个空间
```js
        let fn = {
            name: "张三",
            age: 27
        }
        console.log( fn );
        //{name: '张三', age: 27}
        let cn = fn ;
        cn.name = "王五";
        console.log( fn );
        //{name: '王五', age: 27}
```
### 3、传递参数
+ ECMAScript中所有函数的参数都是按值传递的，不论是引用还是原始，原始值传入参数结束后还是原始值，引用值传入参数结束后引用还是指向原来的引用
```js
        function fn (obj) {
            obj.name = "老王";
            obj = new Object();
           //一旦obj被重写，那么obj不再是外部的指针而是本地的指针
            obj.name = "李四"
            return obj;
        }
        let per = new Object();
        fn(per);
        console.log(per);//{name: '老王'}
```
### 4、值的确定
+ 前面我们使用typeof操作符用于判断变量类型但对引用类型不行
+ 我们可以使用**instanceof**操作符来判断一个对象是否为Object的实例，与java一致
