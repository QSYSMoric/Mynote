## 1、Vue2与Vue3的区别
+ 概述
	1. 新增的Composition API
	2. 模块化的API调用
	3. 基于Fragment的多个根标签调用
	4. 响应式原理
	5. diff算法优化
	6. 生命周期的改变
	7. 新增一些组件，teleport。。。
+ 响应式原理的改变
	1. Vue2主要是通过Object.definProperty进行实现
	2. Vue3主要通过ES6新增的Proxy
	3. 由于defineProperty只能监听指定的对象、指定属性的响应性，所以vue2需要对data中返回的复杂类型进行循环监听
	4. 即因为这样所以我们为响应式数据动态新增属性的时候，那么便失去响应性问题
+ diff算法的优化
	+ vue2的diff算法，大致是通过比较新旧两组节点的四个端点（新旧节点组的开头、结尾）进行对比，并试图找到可复用的
	+ vue3中的diff算法，主要涉及到动规的最长子序列问题，能够减少不必要的 DOM 操作，提升性能
+ 使用上：
	+ Vue2 是选项API（Options API），一个逻辑会散乱在文件不同位置（data、props、computed、watch、生命周期钩子等），导致代码的可读性变差。当需要修改某个逻辑时，需要上下来回跳转文件位置。
	+ Vue3 组合式API（Composition API）则很好地解决了这个问题，可将同一逻辑的内容写到一起，增强了代码的可读性、内聚性，其还提供了较为完美的逻辑复用性方案。
## 2、响应式原理
+ reactive主要是通过proxy进行响应与处理，核心就是监听复杂类型的getter和setter的行为。
+ 当监听到getter行为那么收集使用当前属性的依赖，也就是effect，当触发setter行为的时候那就触发getter收集到的依赖
+ 但是proxy只能监听到复杂类型无法监听简单类型的改变，所以vue提供了ref方法。ref既可以处理简单类型也可以处理复杂类型，当ref接触到复杂类型的时候会通过toReactive方法，将复杂类型交给reactive处理
+ reactive主要处理复杂类型而getValue与setVale处理简单类型，核心主要是监听getter和setter
## 3、computed原理
+ computed与ref的机制是有些类似的，还是通过get Value与set Value来运行的，但是因为计算属性的特性，与ref还是有一些区别，主要在调度器和执行检查
+ 调度器作为effect的回调函数，当初发依赖的时候会执行这个依赖以达到计算后的值
+ 而执行检查即检查当前状态来决定是否执行当前依赖
## 4、watch原理
+ watch是一个懒执行的api，它的本质就是在监听响应式数据变化时，重新执行回调函数
+ 即为数据发送改变时便触发，而getter行为触发是依赖于内部的traverse方法进行的
## 5、H函数与VNode
+ H函数就是用于快速生成Vnode的函数
+ 因为VNode是一个对象，通过这个对象的不同属性来代表真实DOM的不同属性
+ 在内部，H函数是触发了createVNode函数
## 6、H函数支持多种调用方式，如何做到
+ vue在H函数内部对参数类型进行了判断，从根据不同类型，来判断参数的不同作用
## 7、开发使用Render和h函数
+ render函数是 Vue 中的一个核心概念，它用于将虚拟 DOM（Virtual DOM，简称 VDOM）渲染成真实的 DOM，并将其插入到页面的 DOM 树中。
## 8、mixin与hooks
+ mixin：
	+ 混入：提供了方法的实现，在其他类中可以直接访问mixin类中的方法，但不用成为其子类，功能模块完整植入
	+ 提供的是灵活的可复用的方式
	+ 局部混入：子组件需要就声明mixin
	+ 全局混入：Vue.mixin
+ minix缺点：
	1. 变量来源不明确（隐式传入），不利于阅读，使代码变得难以维护
	2. 多个mixins的生命周期会融合到一起运行，但是同名属性、同名方法无法融合，可能会导致冲突。
	3. mixins和组件可能出现多对多的关系，复杂度较高（即一个组件可以引用多个mixins，一个mixins也可以被多个组件引用）。
+ hooks：
	- 使用Vue3的组合API封装的可复用的功能函数
	- 自定义hook的作用类似于vue2中的mixin技术
	- 自定义Hook的优势: 很清楚复用功能代码的来源, 更清楚易懂.
## 9、vue组件通信方式
+ 通信方式综述：父子、兄弟、祖孙后代、非关系通信
### 9.1、props
+ 父组件通过自定义属性传值
### 9.1、$emit
+ 发布订阅模式
### 9.3、ref
```js
<children ref="foo">
//子组件获取
this.$refs.foo //获取
```
### 9.4、EventBus
### 9.5、$attrs $listeners
+ 层级穿透
### 9.6、provide inject
+ provide/inject 是 Vue 在 2.2.0 版本新增的 API，官网这段定义看起来好像有点难理解，通俗的讲，就是 provide 可以在祖先组件中指定我们想要提供给后代组件的数据或方法，而在任何后代组件中，我们都可以使用 inject 来接收 provide 提供的数据或方法。
### 9.7、全局状态管理
## 10、v-if与v-show
+ v-if：开销更大控制dom的添加删除
+ v-show：dom的显示
+ 变动小 v-if
+ 频繁切换：v-show
## 11、Vue key的使用原理
+ 为每个vnode添加唯一id
+ 优化diff算法
+ 不用key 就地复用 element 最小移动 
+ 使用了key vue会根据key的记录找到element
## 12、设置key与不设置key的区别
+ 主要就是为了减少dom的操作
## 13、Vue修饰符
+ 定义：限定类型，限定类型成员的一种符号
+ 常用表单修饰符：
	+ lazy：输入框失去焦点后触发change事件.控制台中输出相应内容。
	+ trim：首位去除空格
	+ number：限制类型为number
+ 常用事件修饰符：
	+ stop：阻止了事件冒泡
	+ prevent：阻止默认事件
	+ self：只有本元素触发事件便会调用
	+ once：触发一次
+ 鼠标修饰符：left、right、middle
+ 键盘修饰符：onKeyup、onKeyDown
## 14、nextTick
+ DOM更新循环后执行延迟回调，在回调中获取最新的DOM
+ Vue更新
## 15、Vue的组件与插件
+ 组件定义：
	+ 组件是可复用的 Vue 实例, 把一些公共的模块抽取出来，然后写成单独的的工具组件或者页面，在需要的页面中就直接引入即可那么我们可以将其抽出为一个组件进行复用。例如 页面头部、侧边、内容区，尾部，上传图片，等多个页面要用到一样的就可以做成组件，提高了代码的复用率。
+ 优点：
	1. 降低耦合度
	2. 调试更加方便
	3. 提升可维护性
+ 插件定义：
	+ Vue添加的全局功能或属性
	+ 全局混入
	+ 全局资源
## 16、自定义指令与插件区别
1. 编写形式
	+ 插件要暴露有install对象
2. 注册形式
3. 使用场景
## 17、SSR服务端的渲染
+ 服务端生成对应html，拼接好所以模板，让浏览器绑定事件
## 18、scoped原理
+ 让元素在本组件生效，不影响其他组件
+ 原理：给组件新增自定义属性 css 根据属性选择器添加样式
## 19、样式穿透
+ 有时候，我们多级嵌套class选择器 的时候scoped永远会将最后一个选择器加上\[唯一属性\]为了让其改变属性选择器的位置那么我们将需要使用样式选择器:deep();改变唯一表示的位置
## 20、nextTick
+ 获取更新后dom的内容