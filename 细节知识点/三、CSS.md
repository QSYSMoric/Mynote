## 1、盒模型
```css
box-sizing: content-box // W3C盒子模型 
box-sizing: border-box // IE盒子模型
```
+ 盒子模型主要与box-sizing有关
+ 普通的盒模型的width要算border与padding所以你定义的width与你得到的width是有所不同的
+ 但标准盒模型的width就是你的content内容宽度
## 2、CSS常见选择器
+ 权重问题：!important > style={} > id > class > 标签 > 子选择器 > 伪类（注意部署伪元素）
+ 相同的选择器下：相同等级或重复写的样式则为最后写的样式为准
## 3、伪类与伪元素
+ 伪类：主要指特定的元素状态
+ 伪元素：主要指的是元素的特定部分
## 4、属性继承
+ 像一般的有：
	1. 字体相关属性： font-family （字体系列） font-size （字体大小） font-weight （字体粗细） font-style （字体样式，如italic）
	2. 文本相关属性： color （文本颜色） line-height （行高） text-align （文本水平对齐） text-decoration （文本装饰，如下划线）
	3. 基本框模型属性： padding （内边距） margin （外边距） border （边框属性）
	4. 列表相关属性： list-style （列表样式）
	5. 表格相关属性： border-collapse （表格边框合并方式） border-spacing （表格边框间距） caption-side （表格标题位置）
	6. 其他属性： visibility （元素可见性）
## 5、行盒与块盒
+ 行盒：主要用于描述文本内容的布局
	+ 不会独占一行，相邻的行内元素会排列在同一行里，直到一行排不下才会自动换行，其宽度随元素的内容而变化；
	+ 高宽无效，对外边距（margin）和内边距（padding）仅设置左右方向有效 上下无效；
	+ 高宽无效，对外边距（margin）和内边距（padding）仅设置左右方向有效 上下无效
	+ 元素的宽度就是它包含的文字或图片的宽度，不可改变
	+ 行内元素中不能放块级元素，a 链接里面不能再放链接
+ 块盒：用于描述元素在布局中的块级行为和特性
	+ 每个块级元素都是独自占一行；
	+ 高度，行高，外边距（margin）以及内边距（padding）都可以控制
	+ 元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%；
	+ 多个块状元素标签写在一起，默认排列方式为从上至下
+ 行盒与块盒不能相邻
## 6、BFC/区块格式化上下文
+ 定义：
	+ 独立的渲染区域
	+ 隔绝与外部的联系
	+ 渲染互不干扰
+ 目的
	+ 解决margin塌陷问题
	+ 不会产生高度坍塌问题
	+ 不会被其他浮动元素所覆盖
## 7、容纳块
+ 每个元素都有一个容纳块，它可以是元素的父元素、祖先元素或根元素（即根据文档流计算的初始容器）。容纳块确定了元素的定位上下文和坐标系。
## 8、画三角形
+ 对于一个没有width与height的盒子来讲，如果设置它的border，会发现它的四个边都是独立的三角形，我们只需要设置其他的边为透明的颜色那么便得到一个三角形
+ 或者使用clip-path，裁剪设置三个角来裁剪一个盒子那么便得到了一个三角形
## 9、不同单位之间的区别
+ **px：** 像素px是相对于显示器屏幕分辨率而言的一个单位  
+ **em：** 相对于当前对象内文本的字体尺寸  
+ **rem：** 相对于根元素\<html>的字体大小 
+ **vh\\vw**：相对于视口的高度和宽度。1vh = 1/100 的浏览窗口高度，1vw = 1/100 的浏览器窗口宽度
## 10、浏览器渲染原理
1. 解析HTML
	+ 解析过程遇到CSS解析CSS，遇到JS执行JS。为了提高效率与性能，浏览器在开始解析之前，会启动一个预解析的过程，在这里会预先下载HTML外部的CSS和JS文件
	+ 遇到link主线程不会等待下载而是继续解析，下载过程放在与解析线程之中
	+ 如果遇到script标签则会停止解析HTML，转而等待JS文件下载完毕。因为js里面可能会修改DOM树
2. 样式计算
	+ 主线程会遍历所得到的DOM树，依次为树中的每个节点计算出它最终的样式，为ComputedStyel，在这过程中预设值会变为绝对值
3. 布局layout
	+ DOM树与布局树不会一一对应
4. 分层
	+  主线程会对布局树进行分层
	+ 优点：将来某个层发生改变后，仅会对该层进行后续处理，从而提升效率
	+ 滚动条、堆叠上下文、transform、opacity等样式或多或少影响分层结果，也可也通过will-change属性更大程度影响分层结果
5. 绘制
	+ 产生绘制指令
6. 分块
	+ 合成线程：启动多个分块器线程
7. 光栅化
	+ 将块变成位图，即为绘制像素点，先绘制视口的块
	+ GPU在做
8. 画
	+ 合成线程计算每个位图在屏幕上的位置，交给GPU进行最终呈现
## 11、层叠样式表
1. 比较重要性
	+ 作者样式表 > 默认样式表
2. 比较特殊性
3. 比较源次序
## 12、line-height与height的区别
+ line-height：是每一行文字的高，如果文字有多行，那么文字之间的空隙就会变大，并且撑大盒子
+ height：就是规定了元素的高
## 13、css选择器
+ \*：通配符选择器
+ id：id选择器
+ class：类选择器
+ 标签选择器
+ 相邻选择器
+ nth-chid：后代选择器
+ >：子选择器
+ a\[href\]：属性选择器
+ 伪类选择器
## 14、优先级算法
+ !import > 内联 > id > class > 标签 > 通配
## 16、清除浮动
1. 触发BFC
2. 在盒子最后创建一个盒子设置：clear：both
3. 伪元素
## 17、什么是css reset
+ reset.css 是一个css文件用于
+ normalize.css 解决跨浏览器的一致性
## 18、css sprite是什么
+ 精灵图
## 19、display：none与visibility：hidden区别
+ display：none
	+ 在解析生成layout的时候不参与render绘制
	+ 不占用原空间
	+ 产生重绘：样式变化例如color
+ visibility：hidden
	+ 在解析的时候是在绘制paint不显示内容
	+ 占用原空间
	+ 产生回流：位置变化
## 20、opacity与rgba的区别
1. **适用对象不同**：`opacity` 适用于整个元素及其内容，而 `rgba` 则适用于指定颜色的部分。
    
2. **透明度计算方式不同**：`opacity` 的取值范围是 0~1，其中 0 表示完全透明，1 表示完全不透明。它的透明度是相对于元素自身的内容的，即如果一个元素设置了 `opacity: 0.5`，那么元素和其所有内容都会半透明。而 `rgba` 是指定颜色的属性，其中的 `a` 值（alpha 值）用于控制透明度，取值范围也是 0~1，它是相对于元素所在背景的透明度。

3. **影响布局与交互不同**：使用 `opacity` 属性来设置透明度会将整个元素及其内容都渲染为半透明，这可能会影响布局和交互。相反，使用 `rgba` 来设置颜色的透明度仅影响指定颜色的部分，不会对元素的布局和其他交互产生影响。
    
4. **兼容性不同**：虽然 `opacity` 和 `rgba` 在现代浏览器中都有良好的支持，但是对于一些旧版本的浏览器，如 IE8 及更早版本，对于 `opacity` 的支持可能存在一些问题。